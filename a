using System;

namespace Binomial
{
    class Program
    {
        static void Main(string[] args)
        {
            double s = 102;
            double k = 96;
            double r = 0.06;
            double q = 0.04;
            double sigma = 0.25;
            double t = 0.5;
            double t0 = 0;
            double n = 5;
            double dt = (t-t0) / n;

            double a = Math.Exp((r - q) * dt);
            double u = Math.Exp(sigma * Math.Sqrt(dt));
            Double d = 1 / u;
            Double p_up = (a - d) / (u - d);
	    Double p_down = 1 - p_up;
            
	    Double Delta = 
	    
            Console.WriteLine(p_up);
	    // static private double a(double q, double r, double dt) {Math.Exp((r-q)*dt); return a;}

        }
        
        
        
        	private double Call(double s, double k)
		{
			return Math.Max(0.0, s - k);
		}

		private double Put(double s, double k)
		{
			return Math.Max(0.0, k - s);
		}
     
        
        
        
    }
}



/* Possible solution found but cannot get to run

using System;

namespace Binomial
{

    public class Options
    {
        public enum PutCallFlag
        {
            Put, Call
        }

        static void Main()
        {
             BinomialTree(95,100,5,0.5,0.06,.03,PutCallFlag.Put,true ,10);
        }
            /// Cox-Ross-Rubinstein Binomial Tree
            /// <returns>price of the option</returns>
           public static double BinomialTree(double strike, double underlyingPrice, double yearsToExpiry, double vol, double riskFreeRate, double dividendYield, PutCallFlag putCallFlag, bool isEuropean, int nSteps)
            {
                double b = riskFreeRate - dividendYield;
                double[] optionValueArray = new double[nSteps + 1];

                int z;
                if (putCallFlag == PutCallFlag.Call)
                    z = 1;
                else z = -1;

                double dt = yearsToExpiry / nSteps;
                double u = Math.Exp(vol * Math.Sqrt(dt));
                double d = 1.0 / u;
                double a = Math.Exp(b * dt);
                double p = (a - d) / (u - d);
                double df = Math.Exp(-riskFreeRate * dt);

                for (int i = 0; i <= nSteps; i++)
                    optionValueArray[i] = Math.Max(0, z * (underlyingPrice * Math.Pow(u, i) * Math.Pow(d, nSteps - i) - strike));

                for (int j = nSteps - 1; j >= 0; j--)
                {
                    for (int i = 0; i <= j; i++)
                    {
                        double e = df * (p * optionValueArray[i + 1] + (1 - p) * optionValueArray[i]);
                        if (isEuropean)
                        {
                            optionValueArray[i] = e;
                        }
                        else
                        {
                            double intrinsic = z * (underlyingPrice * Math.Pow(u, i) * Math.Pow(d, j - i) - strike);
                            optionValueArray[i] = Math.Max(intrinsic, e);
                        }
                    }
                }
                return optionValueArray[0];
            }


        }
    }



*/
